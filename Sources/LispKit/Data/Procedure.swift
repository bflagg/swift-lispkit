//
//  Procedure.swift
//  LispKit
//
//  Created by Matthias Zenger on 21/01/2016.
//  Copyright Â© 2016 ObjectHub. All rights reserved.
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.
//

import Foundation
import Atomics

///
/// Procedures encapsulate functions that can be applied to arguments. Procedures have an
/// identity, a name, and a definition in the form of property `kind`. There are four kinds
/// of procedure definitions:
///    1. Primitives: Built-in procedures
///    2. Closures: User-defined procedures, e.g. via `lambda`. Closure are either anonymous,
///       they are named, or they are continuations
///    3. Parameters: Parameter objects, which can be mutated for the duration of a
///       dynamic extent
///    4. Transformers: User-defined macro transformers defined via `syntax-rules`
///    5. Raw continuations: Continuations generated by `call-with-current-continuation`
///       are modeled as closures of closure type `continuation`. Internally, they use
///       raw continuations for encapsulating the state of a virtual machine.
///
public final class Procedure: Reference, CustomStringConvertible {
  
  /// Count procedure objects
  public static let count = ManagedAtomic<UInt>(0)
  
  /// There are four kinds of procedures:
  ///    1. Primitives: Built-in procedures
  ///    2. Closures: User-defined procedures, e.g. via `lambda`
  ///    3. Parameters: Parameter objects, which can be mutated for the duration of a
  ///       dynamic extent
  ///    4. Transformers: User-defined macro transformers defined via `syntax-rules`
  ///    5. Raw continuations: Continuations generated by `call-with-current-continuation`
  ///       are modeled as closures of closure type `continuation`. Internally, they use
  ///       raw continuations for encapsulating the state of a virtual machine.
  public enum Kind {
    case primitive(String, Implementation, FormCompiler?)
    case closure(ClosureType, Expr, Exprs, Code)
    case parameter(Tuple)
    case transformer(SyntaxRules)
    case rawContinuation(VirtualMachineState)
  }
  
  /// There are three types of closures:
  ///    1. Anonymous closures: closures that are not named
  ///    2. Named closures: Closures that are given a name
  ///    3. Continuations: These are unnamed closures generated by `call-with-current-continuation`
  public enum ClosureType {
    case anonymous
    case named(String)
    case continuation
  }
  
  /// There are three different types of primitive implementations:
  ///    1. Evaluators: They turn the arguments into code that the VM executes
  ///    2. Applicators: They map the arguments to a continuation procedure and an argument list
  ///    3. Native implementations: They map the arguments into a result value
  // TODO: Remove evaluators; they can be represented as applicators returning a newly
  //       generated procedure without arguments.
  public enum Implementation {
    case eval((Arguments) throws -> Code)
    case apply((Arguments) throws -> (Procedure, Exprs))
    case native0(() throws -> Expr)
    case native1((Expr) throws -> Expr)
    case native2((Expr, Expr) throws -> Expr)
    case native3((Expr, Expr, Expr) throws -> Expr)
    case native4((Expr, Expr, Expr, Expr) throws -> Expr)
    case native0O((Expr?) throws -> Expr)
    case native1O((Expr, Expr?) throws -> Expr)
    case native2O((Expr, Expr, Expr?) throws -> Expr)
    case native3O((Expr, Expr, Expr, Expr?) throws -> Expr)
    case native0OO((Expr?, Expr?) throws -> Expr)
    case native1OO((Expr, Expr?, Expr?) throws -> Expr)
    case native2OO((Expr, Expr, Expr?, Expr?) throws -> Expr)
    case native3OO((Expr, Expr, Expr, Expr?, Expr?) throws -> Expr)
    case native0R((Arguments) throws -> Expr)
    case native1R((Expr, Arguments) throws -> Expr)
    case native2R((Expr, Expr, Arguments) throws -> Expr)
    case native3R((Expr, Expr, Expr, Arguments) throws -> Expr)
  }
  
  /// Identifier
  public let id: UInt = Procedure.count.wrappingIncrementThenLoad(ordering: .relaxed)
  
  /// Procedure kind
  public let kind: Kind
  
  /// Is this procedure traced; i.e. should the virtual machine print debugging information
  /// for this procedure?
  public var traced: Bool = false

  /// A tag that defines the last GC cyle in which this object was marked (by following the
  /// root set references); for optimization purposes
  internal final var tag: UInt8 = 0
  
  /// Internal initializer for copying primitive procedures
  private init(_ name: String,
               _ impl: Implementation,
               _ fcomp: FormCompiler?) {
    self.kind = .primitive(name, impl, fcomp)
  }
  
  /// Initializer for primitive evaluators
  public init(_ name: String,
              _ proc: @escaping (Arguments) throws -> Code,
              _ compiler: FormCompiler? = nil) {
    self.kind = .primitive(name, .eval(proc), compiler)
  }
  
  /// Initializer for primitive evaluators
  public init(_ name: String,
              _ compiler: @escaping FormCompiler,
              in context: Context) {
    self.kind = .primitive(name, .eval(
      { [unowned context] (args: Arguments) throws -> Code in
        let expr =
          Expr.pair(
            .symbol(Symbol(context.symbols.intern(name), context.global)),
            .makeList(args))
        return try Compiler.compile(expr: .pair(expr, .null),
                                    in: context.global,
                                    optimize: true)
      }), compiler)
  }
  
  /// Initializer for primitive applicators
  public init(_ name: String,
              _ proc: @escaping (Arguments) throws -> (Procedure, Exprs),
              _ compiler: FormCompiler? = nil) {
    self.kind = .primitive(name, .apply(proc), compiler)
  }
  
  /// Initializer for primitive procedures
  public init(_ name: String,
              _ proc: @escaping () throws -> Expr,
              _ compiler: FormCompiler? = nil) {
    self.kind = .primitive(name, .native0(proc), compiler)
  }
  
  /// Initializer for primitive procedures
  public init(_ name: String,
              _ proc: @escaping (Expr) throws -> Expr,
              _ compiler: FormCompiler? = nil) {
    self.kind = .primitive(name, .native1(proc), compiler)
  }
  
  /// Initializer for primitive procedures
  public init(_ name: String,
              _ proc: @escaping (Expr, Expr) throws -> Expr,
              _ compiler: FormCompiler? = nil) {
    self.kind = .primitive(name, .native2(proc), compiler)
  }
  
  /// Initializer for primitive procedures
  public init(_ name: String,
              _ proc: @escaping (Expr, Expr, Expr) throws -> Expr,
              _ compiler: FormCompiler? = nil) {
    self.kind = .primitive(name, .native3(proc), compiler)
  }
  
  /// Initializer for primitive procedures
  public init(_ name: String,
              _ proc: @escaping (Expr, Expr, Expr, Expr) throws -> Expr,
              _ compiler: FormCompiler? = nil) {
    self.kind = .primitive(name, .native4(proc), compiler)
  }
  
  /// Initializer for primitive procedures
  public init(_ name: String,
              _ proc: @escaping (Expr?) throws -> Expr,
              _ compiler: FormCompiler? = nil) {
    self.kind = .primitive(name, .native0O(proc), compiler)
  }

  /// Initializer for primitive procedures
  public init(_ name: String,
              _ proc: @escaping (Expr, Expr?) throws -> Expr,
              _ compiler: FormCompiler? = nil) {
    self.kind = .primitive(name, .native1O(proc), compiler)
  }
  
  /// Initializer for primitive procedures
  public init(_ name: String,
              _ proc: @escaping (Expr, Expr, Expr?) throws -> Expr,
              _ compiler: FormCompiler? = nil) {
    self.kind = .primitive(name, .native2O(proc), compiler)
  }
  
  /// Initializer for primitive procedures
  public init(_ name: String,
              _ proc: @escaping (Expr, Expr, Expr, Expr?) throws -> Expr,
              _ compiler: FormCompiler? = nil) {
    self.kind = .primitive(name, .native3O(proc), compiler)
  }

  /// Initializer for primitive procedures
  public init(_ name: String,
              _ proc: @escaping (Expr?, Expr?) throws -> Expr,
              _ compiler: FormCompiler? = nil) {
    self.kind = .primitive(name, .native0OO(proc), compiler)
  }
  
  /// Initializer for primitive procedures
  public init(_ name: String,
              _ proc: @escaping (Expr, Expr?, Expr?) throws -> Expr,
              _ compiler: FormCompiler? = nil) {
    self.kind = .primitive(name, .native1OO(proc), compiler)
  }
  
  /// Initializer for primitive procedures
  public init(_ name: String,
              _ proc: @escaping (Expr, Expr, Expr?, Expr?) throws -> Expr,
              _ compiler: FormCompiler? = nil) {
    self.kind = .primitive(name, .native2OO(proc), compiler)
  }
  
  /// Initializer for primitive procedures
  public init(_ name: String,
              _ proc: @escaping (Expr, Expr, Expr, Expr?, Expr?) throws -> Expr,
              _ compiler: FormCompiler? = nil) {
    self.kind = .primitive(name, .native3OO(proc), compiler)
  }
  
  /// Initializer for primitive procedures
  public init(_ name: String,
              _ proc: @escaping (Arguments) throws -> Expr,
              _ compiler: FormCompiler? = nil) {
    self.kind = .primitive(name, .native0R(proc), compiler)
  }
  
  /// Initializer for primitive procedures
  public init(_ name: String,
              _ proc: @escaping (Expr, Arguments) throws -> Expr,
              _ compiler: FormCompiler? = nil) {
    self.kind = .primitive(name, .native1R(proc), compiler)
  }
  
  /// Initializer for primitive procedures
  public init(_ name: String,
              _ proc: @escaping (Expr, Expr, Arguments) throws -> Expr,
              _ compiler: FormCompiler? = nil) {
    self.kind = .primitive(name, .native2R(proc), compiler)
  }
  
  /// Initializer for primitive procedures
  public init(_ name: String,
              _ proc: @escaping (Expr, Expr, Expr, Arguments) throws -> Expr,
              _ compiler: FormCompiler? = nil) {
    self.kind = .primitive(name, .native3R(proc), compiler)
  }
  
  /// Initializer for closures
  public init(_ type: ClosureType, _ tag: Expr, _ captured: Exprs, _ code: Code) {
    self.kind = .closure(type, tag, captured, code)
  }
  
  /// Initializer for closures
  public init(_ type: ClosureType, _ captured: Exprs, _ code: Code) {
    self.kind = .closure(type, .undef, captured, code)
  }
  
  /// Initializer for closures
  public init(_ code: Code) {
    self.kind = .closure(.anonymous, .undef, [], code)
  }
  
  /// Initializer for named closures
  public init(_ name: String, _ code: Code) {
    self.kind = .closure(.named(name), .undef, [], code)
  }
  
  /// Initializer for parameters
  public init(_ setter: Expr, _ initial: Expr) {
    self.kind = .parameter(Tuple(setter, initial))
  }
  
  /// Initializer for parameters
  public init(_ tuple: Tuple) {
    self.kind = .parameter(tuple)
  }
  
  /// Initializer for continuations
  public init(_ vmState: VirtualMachineState) {
    self.kind = .rawContinuation(vmState)
  }
  
  /// Initializer for transformers
  public init(_ rules: SyntaxRules) {
    self.kind = .transformer(rules)
  }
  
  public override init() {
    preconditionFailure()
  }
  
  /// Returns the name of this procedure. This method either returns the name of a primitive
  /// procedure or the identity as a hex string.
  public var name: String {
    switch self.kind {
      case .primitive(let str, _, _):
        return str
      case .closure(.named(let str), _, _, _):
        return Context.simplifiedDescriptions ? str : "\(str)@\(self.id)"
      default:
        return "<closure \(self.id)>"
    }
  }

  /// Returns the name of this procedure. This method either returns the name of a primitive
  /// procedure or the identity as a hex string or `nil` if there is no available name.
  public var embeddedName: String {
    switch self.kind {
      case .primitive(let str, _, _):
        return str
      case .closure(.named(let str), _, _, _):
        return Context.simplifiedDescriptions ? str : "\(str)@\(self.id)"
      default:
        return "\(self.id)"
    }
  }
  
  /// Returns the original name of this procedure if it exists and is known.
  public var originalName: String? {
    switch self.kind {
      case .primitive(let str, _, _):
        return str
      case .closure(.named(let str), _, _, _):
        return str
      default:
        return nil
    }
  }
  
  /// Return a renamed procedure (if renaming is possible)
  public func renamed(to name: String, force: Bool = false) -> Procedure? {
    switch self.kind {
      case .primitive(_, let impl, let fcomp):
        guard force else {
          return nil
        }
        let res = Procedure(name, impl, fcomp)
        res.traced = self.traced
        return res
      case .closure(let type, let tag, let captured, let code):
        if case .continuation = type {
          return nil
        } else if !force, case .named(_) = type {
          return nil
        }
        let res = Procedure(.named(name), tag, captured, code)
        res.traced = self.traced
        return res
      default:
        return nil
    }
  }
  
  /// Arities are either exact or they are referring to a lower bound.
  public enum Arity {
    case exact(Int)
    case atLeast(Int)
  }
  
  /// Returns the arity.
  public var arity: [Arity] {
    switch self.kind {
      case .primitive(_, let impl, _):
        switch impl {
          case .eval(_):
            return [.atLeast(0)]
          case .apply(_):
            return [.atLeast(0)]
          case .native0(_):
            return [.exact(0)]
          case .native1(_):
            return [.exact(1)]
          case .native2(_):
            return [.exact(2)]
          case .native3(_):
            return [.exact(3)]
          case .native4(_):
            return [.exact(4)]
          case .native0O(_):
            return [.exact(0), .exact(1)]
          case .native1O(_):
            return [.exact(1), .exact(2)]
          case .native2O(_):
            return [.exact(2), .exact(3)]
          case .native3O(_):
            return [.exact(3), .exact(4)]
          case .native0OO(_):
            return [.exact(0), .exact(1), .exact(2)]
          case .native1OO(_):
            return [.exact(1), .exact(2), .exact(3)]
          case .native2OO(_):
            return [.exact(2), .exact(3), .exact(4)]
          case .native3OO(_):
            return [.exact(3), .exact(4), .exact(5)]
          case .native0R(_):
            return [.atLeast(0)]
          case .native1R(_):
            return [.atLeast(1)]
          case .native2R(_):
            return [.atLeast(2)]
          case .native3R(_):
            return [.atLeast(3)]
        }
      case .closure(.continuation, _, _, _):
        return [.exact(1)]
      case .closure(_, _, _, let code):
        return code.arity
      case .parameter(_):
        return [.exact(0), .exact(1)]
      case .transformer(_):
        return [.exact(1)]
      case .rawContinuation(_):
        return [.exact(1)]
    }
  }
  
  /// Returns `true` if the given arity is accepted by the procedure.
  public func arityAccepted(_ n: Int) -> Bool {
    switch self.kind {
      case .primitive(_, let impl, _):
        switch impl {
          case .eval(_), .apply(_), .native0R(_):
            return true
          case .native0(_):
            return n == 0
          case .native1(_):
            return n == 1
          case .native2(_):
            return n == 2
          case .native3(_):
            return n == 3
          case .native4(_):
            return n == 4
          case .native0O(_):
            return n <= 1
          case .native1O(_):
            return n == 1 || n == 2
          case .native2O(_):
            return n == 2 || n == 3
          case .native3O(_):
            return n == 3 || n == 4
          case .native0OO(_):
            return n <= 2
          case .native1OO(_):
            return n >= 1 && n <= 3
          case .native2OO(_):
            return n >= 2 && n <= 4
          case .native3OO(_):
            return n >= 3 && n <= 5
          case .native1R(_):
            return n >= 1
          case .native2R(_):
            return n >= 2
          case .native3R(_):
            return n >= 3
        }
      case .closure(.continuation, _, _, _):
        return n == 1
      case .closure(_, _, _, let code):
        return code.arityAccepted(n)
      case .parameter(_):
        return n <= 1
      case .transformer(_):
        return n == 1
      case .rawContinuation(_):
        return n == 1
    }
  }
  
  /// A textual description
  public var description: String {
    return "Â«procedure \(self.name)Â»"
  }
  
  /// Returns a textual representation of the disassembled code
  public func disassembled(all: Bool = true) -> String? {
    var builder = StringBuilder()
    var procToDisassemble: [Procedure] = [self]
    var i = 0
    while i < procToDisassemble.count {
      let proc = procToDisassemble[i]
      switch proc.kind {
        case .closure(_, _, let captured, let code):
          if !builder.isEmpty {
            builder.appendNewline()
          }
          builder.append("====== \(Expr.procedure(proc).description) ======")
          builder.appendNewline()
          builder.append(code.description)
          if captured.count > 0 {
            builder.append("CAPTURED:")
            for n in captured.indices {
              builder.appendNewline()
              builder.append(n, width: 5, alignRight: true)
              builder.append(": ")
              builder.append(captured[n].description)
            }
            builder.appendNewline()
          }
          if all {
            for expr in code.constants {
              if case .procedure(let proc) = expr {
                procToDisassemble.append(proc)
              }
            }
          }
        case .rawContinuation(let vmState):
          if !builder.isEmpty {
            builder.appendNewline()
          }
          builder.append("====== \(Expr.procedure(proc).description) ======")
          builder.appendNewline()
          builder.append(vmState.description)
          builder.appendNewline()
          builder.append(vmState.registers.code.description)
          if vmState.registers.captured.count > 0 {
            builder.append("CAPTURED:")
            for n in vmState.registers.captured.indices {
              builder.appendNewline()
              builder.append(n, width: 5, alignRight: true)
              builder.append(": ")
              builder.append(vmState.registers.captured[n].description)
            }
            builder.appendNewline()
          }
          if all {
            for expr in vmState.registers.code.constants {
              if case .procedure(let proc) = expr {
                procToDisassemble.append(proc)
              }
            }
          }
        default:
          break
      }
      i += 1
    }
    let res = builder.description
    return res.count > 0 ? res : nil
  }
}

public typealias Arguments = ArraySlice<Expr>

public extension Arguments {

  var values: Expr {
    switch self.count {
      case 0:
        return .void
      case 1:
        return self.first!
      default:
        var res = Expr.null
        var idx = self.endIndex
        while idx > self.startIndex {
          idx = self.index(before: idx)
          res = .pair(self[idx], res)
        }
        return .values(res)
    }
  }
}

public extension ArraySlice {
    
  func optional(_ fst: Element, _ snd: Element) -> (Element, Element)? {
    switch self.count {
      case 0:
        return (fst, snd)
      case 1:
        return (self[self.startIndex], snd)
      case 2:
        return (self[self.startIndex], self[self.startIndex + 1])
      default:
        return nil
    }
  }
  
  func optional(_ fst: Element, _ snd: Element, _ trd: Element) -> (Element, Element, Element)? {
    switch self.count {
      case 0:
        return (fst, snd, trd)
      case 1:
        return (self[self.startIndex], snd, trd)
      case 2:
        return (self[self.startIndex], self[self.startIndex + 1], trd)
      case 3:
        return (self[self.startIndex], self[self.startIndex + 1], self[self.startIndex + 2])
      default:
        return nil
    }
  }
  
  func optional(_ fst: Element,
                _ snd: Element,
                _ trd: Element,
                _ fth: Element) -> (Element, Element, Element, Element)? {
    switch self.count {
      case 0:
        return (fst, snd, trd, fth)
      case 1:
        return (self[self.startIndex], snd, trd, fth)
      case 2:
        return (self[self.startIndex], self[self.startIndex + 1], trd, fth)
      case 3:
        return (self[self.startIndex], self[self.startIndex + 1], self[self.startIndex + 2], fth)
      case 4:
        return (self[self.startIndex],
                self[self.startIndex + 1],
                self[self.startIndex + 2],
                self[self.startIndex + 3])
      default:
        return nil
    }
  }
  
  func optional(_ fst: Element,
                _ snd: Element,
                _ trd: Element,
                _ fth: Element,
                _ tth: Element) -> (Element, Element, Element, Element, Element)? {
    switch self.count {
      case 0:
        return (fst, snd, trd, fth, tth)
      case 1:
        return (self[self.startIndex], snd, trd, fth, tth)
      case 2:
        return (self[self.startIndex], self[self.startIndex + 1], trd, fth, tth)
      case 3:
        return (self[self.startIndex], self[self.startIndex + 1], self[self.startIndex + 2], fth, tth)
      case 4:
        return (self[self.startIndex],
                self[self.startIndex + 1],
                self[self.startIndex + 2],
                self[self.startIndex + 3],
                tth)
      case 5:
        return (self[self.startIndex],
                self[self.startIndex + 1],
                self[self.startIndex + 2],
                self[self.startIndex + 3],
                self[self.startIndex + 4])
      default:
        return nil
    }
  }
  
  func optional(_ fst: Element,
                _ snd: Element,
                _ trd: Element,
                _ fth: Element,
                _ tth: Element,
                _ sth: Element) -> (Element, Element, Element, Element, Element, Element)? {
    switch self.count {
      case 0:
        return (fst, snd, trd, fth, tth, sth)
      case 1:
        return (self[self.startIndex], snd, trd, fth, tth, sth)
      case 2:
        return (self[self.startIndex], self[self.startIndex + 1], trd, fth, tth, sth)
      case 3:
        return (self[self.startIndex], self[self.startIndex + 1], self[self.startIndex + 2], fth, tth, sth)
      case 4:
        return (self[self.startIndex],
                self[self.startIndex + 1],
                self[self.startIndex + 2],
                self[self.startIndex + 3],
                tth,
                sth)
      case 5:
        return (self[self.startIndex],
                self[self.startIndex + 1],
                self[self.startIndex + 2],
                self[self.startIndex + 3],
                self[self.startIndex + 4],
                sth)
      case 6:
        return (self[self.startIndex],
                self[self.startIndex + 1],
                self[self.startIndex + 2],
                self[self.startIndex + 3],
                self[self.startIndex + 4],
                self[self.startIndex + 5])
      default:
        return nil
    }
  }
  
  func required2() -> (Element, Element)? {
    guard self.count == 2 else {
      return nil
    }
    return (self[self.startIndex], self[self.startIndex + 1])
  }
  
  func required3() -> (Element, Element, Element)? {
    guard self.count == 3 else {
      return nil
    }
    return (self[self.startIndex], self[self.startIndex + 1], self[self.startIndex + 2])
  }
}

///
/// A `FormCompiler` is a function that compiles an expression for a given compiler in a
/// given environment and tail position returning a boolean which indicates whether the
/// expression has resulted in a tail call.
///
public typealias FormCompiler = (Compiler, Expr, Env, Bool) throws -> Bool
